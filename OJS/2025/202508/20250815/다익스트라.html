<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ ì‹œê°í™”</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh; color: #333;
    }
    .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
    .header { text-align: center; color: white; margin-bottom: 40px; }
    .header h1 { font-size: 3rem; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
    .header p { font-size: 1.2rem; opacity: 0.9; }
    .content-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 40px; }
    .card {
      background: white; border-radius: 15px; padding: 30px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2); transition: transform 0.3s ease;
    }
    .card:hover { transform: translateY(-5px); }
    .card h2 { color: #667eea; margin-bottom: 20px; font-size: 1.8rem; }
    .algorithm-steps { list-style: none; counter-reset: step-counter; }
    .algorithm-steps li {
      counter-increment: step-counter; margin-bottom: 15px; padding-left: 40px;
      position: relative; line-height: 1.6;
    }
    .algorithm-steps li::before {
      content: counter(step-counter); position: absolute; left: 0; top: 0;
      background: #667eea; color: white; width: 25px; height: 25px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9rem;
    }
    .visualization {
      grid-column: 1 / -1; background: white; border-radius: 15px; padding: 30px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    .graph-container {
      display: flex; justify-content: center; align-items: center; min-height: 600px;
      position: relative; margin: 20px 0;
    }
    .node {
      width: 60px; height: 60px; border-radius: 50%;
      background: #f0f0f0; border: 3px solid #ddd;
      display: flex; align-items: center; justify-content: center;
      font-weight: bold; font-size: 1.2rem; position: absolute; cursor: pointer;
      transition: all 0.3s ease; z-index: 10;
    }
    .node.start { background: #4CAF50; color: white; border-color: #45a049; }
    .node.visited { background: #2196F3; color: white; border-color: #1976D2; }
    .node.current { background: #FF9800; color: white; border-color: #F57C00; transform: scale(1.1); }

    /* SVG line ìƒíƒœ ì‹œê°í™” */
    line.queued   { stroke: #FFB74D; stroke-dasharray: 6 6; }
    line.selected { stroke: #FF9800; stroke-width: 5; }

    .edge-weight {
      position: absolute; background: white; border: 2px solid #ddd; border-radius: 15px;
      padding: 5px 10px; font-weight: bold; font-size: 0.9rem; z-index: 5; min-width: 30px; text-align: center;
      left: 0; top: 0; transform: translate(-50%, -50%); pointer-events: none;
    }
    .controls { text-align: center; margin-top: 30px; }
    .btn {
      background: #667eea; color: white; border: none; padding: 12px 24px; border-radius: 25px;
      font-size: 1rem; cursor: pointer; margin: 0 10px; transition: all 0.3s ease;
    }
    .btn:hover { background: #5a6fd8; transform: translateY(-2px); }
    .btn:disabled { background: #ccc; cursor: not-allowed; transform: none; }
    .distance-table { margin-top: 20px; width: 100%; border-collapse: collapse; }
    .distance-table th, .distance-table td { padding: 10px; text-align: center; border: 1px solid #ddd; }
    .distance-table th { background: #667eea; color: white; }
    .distance-table .infinity { color: #999; }
    .distance-table .current-distance { background: #fff3cd; font-weight: bold; }
    @media (max-width: 768px) {
      .content-grid { grid-template-columns: 1fr; }
      .header h1 { font-size: 2rem; }
      .node { width: 50px; height: 50px; font-size: 1rem; }
    }
  </style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜</h1>
    <p>ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ” ê·¸ë˜í”„ ì•Œê³ ë¦¬ì¦˜ì„ ì‹œê°ì ìœ¼ë¡œ í•™ìŠµí•´ë³´ì„¸ìš”</p>
  </div>

  <div class="content-grid">
    <div class="card">
      <h2>ğŸ¯ ì•Œê³ ë¦¬ì¦˜ ê°œìš”</h2>
      <p><strong>ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜</strong>ì€ ê·¸ë˜í”„ì—ì„œ í•œ ì •ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.</p>
      <br>
      <p><strong>íŠ¹ì§•:</strong></p>
      <ul style="margin-left: 20px; margin-top: 10px;">
        <li>ìŒìˆ˜ ê°€ì¤‘ì¹˜ê°€ ì—†ëŠ” ê·¸ë˜í”„ì—ì„œ ì‚¬ìš©</li>
        <li>ì‹œê°„ ë³µì¡ë„: O((V+E)logV)</li>
        <li>ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì˜ ëŒ€í‘œì ì¸ ì˜ˆ</li>
      </ul>
    </div>

    <div class="card">
      <h2>ğŸ“‹ ì•Œê³ ë¦¬ì¦˜ ë‹¨ê³„</h2>
      <ol class="algorithm-steps">
        <li>ì‹œì‘ ì •ì ì˜ ê±°ë¦¬ë¥¼ 0ìœ¼ë¡œ, ë‚˜ë¨¸ì§€ëŠ” ë¬´í•œëŒ€ë¡œ ì„¤ì •</li>
        <li>ë°©ë¬¸í•˜ì§€ ì•Šì€ ì •ì  ì¤‘ ê±°ë¦¬ê°€ ê°€ì¥ ì§§ì€ ì •ì  ì„ íƒ</li>
        <li>ì„ íƒëœ ì •ì ì˜ ì¸ì ‘ ì •ì ë“¤ì˜ ê±°ë¦¬ ì—…ë°ì´íŠ¸</li>
        <li>ì„ íƒëœ ì •ì ì„ ë°©ë¬¸ ì™„ë£Œë¡œ í‘œì‹œ</li>
        <li>ëª¨ë“  ì •ì ì„ ë°©ë¬¸í•  ë•Œê¹Œì§€ 2-4ë‹¨ê³„ ë°˜ë³µ</li>
      </ol>
    </div>
  </div>

  <div class="visualization">
    <h2 style="text-align: center; color: #667eea; margin-bottom: 20px;">ğŸ” ì•Œê³ ë¦¬ì¦˜ ì‹œê°í™”</h2>

    <div class="graph-container" id="graphContainer">
      <!-- ê°„ì„ : ì¢Œí‘œëŠ” JSì—ì„œ ìë™ ì„¤ì • -->
      <svg id="graphSvg" width="100%" height="100%" style="position:absolute; top:0; left:0; z-index:1;">
        <line data-edge="A-B" stroke="#ddd" stroke-width="3"/>
        <line data-edge="A-C" stroke="#ddd" stroke-width="3"/>
        <line data-edge="A-D" stroke="#ddd" stroke-width="3"/>
        <line data-edge="B-C" stroke="#ddd" stroke-width="3"/>
        <line data-edge="B-E" stroke="#ddd" stroke-width="3"/>
        <line data-edge="C-E" stroke="#ddd" stroke-width="3"/>
        <line data-edge="D-E" stroke="#ddd" stroke-width="3"/>
      </svg>

      <!-- ë…¸ë“œë“¤ (absolute ë°°ì¹˜) -->
      <div class="node start" style="top: 70px; left: 370px;" data-node="A">A</div>
      <div class="node" style="top: 170px; left: 520px;" data-node="B">B</div>
      <div class="node" style="top: 70px; left: 670px;" data-node="C">C</div>
      <div class="node" style="top: 370px; left: 370px;" data-node="D">D</div>
      <div class="node" style="top: 300px; left: 600px;" data-node="E">E</div>

      <!-- ê°€ì¤‘ì¹˜ (ìë™ ë°°ì¹˜ìš© data-weight ë¶€ì—¬) -->
      <div class="edge-weight" data-weight="A-B">4</div>
      <div class="edge-weight" data-weight="A-C">10</div>
      <div class="edge-weight" data-weight="A-D">3</div>
      <div class="edge-weight" data-weight="B-C">2</div>
      <div class="edge-weight" data-weight="B-E">1</div>
      <div class="edge-weight" data-weight="C-E">5</div>
      <div class="edge-weight" data-weight="D-E">2</div>
    </div>

    <div class="controls">
      <button class="btn" onclick="startAlgorithm()">ì•Œê³ ë¦¬ì¦˜ ì‹œì‘</button>
      <button class="btn" onclick="nextStep()" id="nextBtn" disabled>ë‹¤ìŒ ë‹¨ê³„</button>
      <button class="btn" onclick="resetGraph()">ì´ˆê¸°í™”</button>
    </div>

    <!-- PQ íŒ¨ë„ -->
    <div class="card" style="margin-top:20px;">
      <h2 style="color:#667eea; margin-bottom:12px;">ğŸ§º Priority Queue</h2>
      <div id="pqList" style="display:flex; gap:8px; flex-wrap:wrap;"></div>
    </div>

    <table class="distance-table" id="distanceTable" style="margin-top:20px;">
      <thead>
        <tr>
          <th>ì •ì </th>
          <th>A</th>
          <th>B</th>
          <th>C</th>
          <th>D</th>
          <th>E</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>ê±°ë¦¬</strong></td>
          <td id="dist-A">0</td>
          <td id="dist-B" class="infinity">âˆ</td>
          <td id="dist-C" class="infinity">âˆ</td>
          <td id="dist-D" class="infinity">âˆ</td>
          <td id="dist-E" class="infinity">âˆ</td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<script>
/* ---------- ê·¸ë˜í”„ ë°ì´í„° ---------- */
const graph = {
  'A': [['B', 4], ['C', 10], ['D', 3]],
  'B': [['A', 4], ['C', 2], ['E', 1]],
  'C': [['A', 10], ['B', 2], ['E', 5]],
  'D': [['A', 3], ['E', 2]],
  'E': [['B', 1], ['C', 5], ['D', 2]]
};

let distances = {};
let visited = new Set();
let currentNode = null;
let isRunning = false;
let prev = {}; // ìµœë‹¨ ê²½ë¡œ íŠ¸ë¦¬ ë¶€ëª¨

/* ---------- Min-Heap (PriorityQueue) ---------- */
class MinHeap {
  constructor(cmp) { this._h = []; this._cmp = cmp || ((a,b)=>a-b); }
  size() { return this._h.length; }
  peek() { return this._h[0]; }
  clear() { this._h = []; }
  push(v) { this._h.push(v); this._up(this._h.length-1); }
  pop() {
    if (this._h.length === 0) return undefined;
    const top = this._h[0];
    const last = this._h.pop();
    if (this._h.length) { this._h[0] = last; this._down(0); }
    return top;
  }
  _up(i){
    const h=this._h, cmp=this._cmp;
    while(i>0){
      const p=(i-1)>>1;
      if (cmp(h[i],h[p])>=0) break;
      [h[i],h[p]]=[h[p],h[i]];
      i=p;
    }
  }
  _down(i){
    const h=this._h, cmp=this._cmp, n=h.length;
    while(true){
      let l=i*2+1, r=l+1, s=i;
      if (l<n && cmp(h[l],h[s])<0) s=l;
      if (r<n && cmp(h[r],h[s])<0) s=r;
      if (s===i) break;
      [h[i],h[s]]=[h[s],h[i]];
      i=s;
    }
  }
}
const pq = new MinHeap((a,b)=> a.dist - b.dist);

/* ---------- ìœ„ì¹˜ ê³„ì‚° & ìë™ ë ˆì´ì•„ì›ƒ ---------- */
function getNodeCenter(nodeId) {
  const container = document.getElementById('graphContainer');
  const nodeEl = document.querySelector(`.node[data-node="${nodeId}"]`);
  if (!container || !nodeEl) return { x: 0, y: 0 };
  const cRect = container.getBoundingClientRect();
  const nRect = nodeEl.getBoundingClientRect();
  return {
    x: (nRect.left - cRect.left) + nRect.width / 2,
    y: (nRect.top - cRect.top) + nRect.height / 2
  };
}

function layoutEdges() {
  const svg = document.getElementById('graphSvg');
  const container = document.getElementById('graphContainer');
  if (!svg || !container) return;

  const cRect = container.getBoundingClientRect();
  svg.setAttribute('width', cRect.width);
  svg.setAttribute('height', cRect.height);

  // ê°„ì„  ì„ ë¶„
  document.querySelectorAll('[data-edge]').forEach(line => {
    const edge = line.getAttribute('data-edge');
    if (!edge) return;
    const [from, to] = edge.split('-');
    const p1 = getNodeCenter(from);
    const p2 = getNodeCenter(to);
    line.setAttribute('x1', p1.x);
    line.setAttribute('y1', p1.y);
    line.setAttribute('x2', p2.x);
    line.setAttribute('y2', p2.y);
  });

  // ê°€ì¤‘ì¹˜ ë¼ë²¨(ê°„ì„  ì¤‘ê°„ ì§€ì  ë°°ì¹˜)
  document.querySelectorAll('.edge-weight[data-weight]').forEach(label => {
    const key = label.getAttribute('data-weight');
    if (!key) return;
    const [from, to] = key.split('-');
    const p1 = getNodeCenter(from);
    const p2 = getNodeCenter(to);
    const midX = (p1.x + p2.x) / 2;
    const midY = (p1.y + p2.y) / 2;
    label.style.transform = `translate(${midX}px, ${midY}px) translate(-50%, -50%)`;
  });
}

/* ---------- ê°„ì„  í´ë˜ìŠ¤ í† ê¸€ ìœ í‹¸ ---------- */
function edgeEls(from, to) {
  return [
    document.querySelector(`[data-edge="${from}-${to}"]`),
    document.querySelector(`[data-edge="${to}-${from}"]`)
  ];
}
function addEdgeClass(from, to, cls) {
  edgeEls(from,to).forEach(el => el && el.classList.add(cls));
}
function removeEdgeClass(from, to, cls) {
  edgeEls(from,to).forEach(el => el && el.classList.remove(cls));
}

/* ---------- PQ íŒ¨ë„ ë Œë” ---------- */
function renderPQ() {
  const box = document.getElementById('pqList');
  if (!box) return;
  const items = pq._h.slice().sort((a,b)=>a.dist-b.dist);
  box.innerHTML = items.map(it =>
    `<span style="border:1px solid #ddd; border-radius:14px; padding:4px 10px; background:#f8f8ff;">
      ${it.node}: ${it.dist}
     </span>`
  ).join('');
}

/* ---------- ì•Œê³ ë¦¬ì¦˜ ì œì–´ ---------- */
function startAlgorithm() {
  resetGraph(false); // ì´ˆê¸°í™”(ë²„íŠ¼/ì•Œë¦¼ ì œì™¸)
  isRunning = true;

  // ì‹œì‘ ì •ì  ì´ˆê¸° ìƒíƒœ
  pq.clear();
  pq.push({ node: 'A', dist: 0 });
  const startEl = document.querySelector('[data-node="A"]');
  if (startEl) startEl.classList.add('current');

  document.getElementById('nextBtn').disabled = false;
  document.querySelector('button[onclick="startAlgorithm()"]').disabled = true;

  layoutEdges();
  renderPQ();
}

function nextStep() {
  if (!isRunning) return;

  // ì´ì „ current í‘œì‹œ ì •ë¦¬
  document.querySelectorAll('.node.current').forEach(n => n.classList.remove('current'));

  // PQì—ì„œ ì•„ì§ ë°©ë¬¸ ì•ˆ ëœ ìµœë‹¨ê±°ë¦¬ ì •ì  êº¼ë‚´ê¸°
  let picked = null;
  while (pq.size() > 0) {
    const top = pq.pop();
    if (!visited.has(top.node)) { picked = top; break; }
  }

  if (!picked) { finishAlgorithm(); return; }

  const u = picked.node, du = picked.dist;

  // ë°©ë¬¸ í™•ì •
  visited.add(u);
  const uEl = document.querySelector(`.node[data-node="${u}"]`);
  if (uEl) { uEl.classList.add('visited'); uEl.classList.add('current'); }
  currentNode = u;

  // ë°©ë¬¸ í™•ì • ê°„ì„  ì‹œê°í™” (ë¶€ëª¨ ê°„ì„ )
  if (prev[u]) {
    removeEdgeClass(prev[u], u, 'queued');   // ì ì„  í•´ì œ
    addEdgeClass(prev[u], u, 'selected');    // êµµì€ ì£¼í™© ê°•ì¡°
    setTimeout(() => removeEdgeClass(prev[u], u, 'selected'), 800);
  }

  // ì´ì›ƒ ì™„í™”(relax)
  (graph[u] || []).forEach(([v, w]) => {
    const alt = du + w;
    if (alt < distances[v]) {
      distances[v] = alt;
      prev[v] = u;
      pq.push({ node: v, dist: alt });
      addEdgeClass(u, v, 'queued'); // íì— ë“¤ì–´ê°„ ê°„ì„ ì€ ì ì„ 
    }
  });

  updateDistanceTable();
  layoutEdges();
  renderPQ();

  if (pq.size() === 0) finishAlgorithm();
}

function finishAlgorithm() {
  isRunning = false;
  document.getElementById('nextBtn').disabled = true;
  document.querySelector('button[onclick="startAlgorithm()"]').disabled = false;
  alert('ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤! ëª¨ë“  ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤.');
}

function resetGraph(showButtons = true) {
  // ë…¸ë“œ ë¦¬ì…‹
  document.querySelectorAll('.node').forEach(node => {
    node.className = 'node';
    if (node.dataset.node === 'A') node.classList.add('start');
  });

  // ê°„ì„  ë¦¬ì…‹ (ìƒ‰/ë‘ê»˜/í´ë˜ìŠ¤)
  document.querySelectorAll('line[data-edge]').forEach(edge => {
    edge.setAttribute('stroke', '#ddd');
    edge.setAttribute('stroke-width', '3');
    edge.classList.remove('queued','selected');
  });

  // ìƒíƒœ ë¦¬ì…‹
  distances = { 'A': 0, 'B': Infinity, 'C': Infinity, 'D': Infinity, 'E': Infinity };
  visited.clear();
  currentNode = null;
  isRunning = false;
  prev = {};
  pq.clear();

  if (showButtons) {
    document.getElementById('nextBtn').disabled = true;
    const startBtn = document.querySelector('button[onclick="startAlgorithm()"]');
    if (startBtn) startBtn.disabled = false;
  }

  updateDistanceTable();
  layoutEdges();
  renderPQ();
}

/* ---------- í…Œì´ë¸” ê°±ì‹  ---------- */
function updateDistanceTable() {
  Object.keys(distances).forEach(node => {
    const cell = document.getElementById(`dist-${node}`);
    if (!cell) return;
    const d = distances[node];
    if (d === Infinity) {
      cell.textContent = 'âˆ';
      cell.className = 'infinity';
    } else {
      cell.textContent = d;
      cell.className = visited.has(node) ? '' : 'current-distance';
    }
  });
}

/* ---------- ì´ˆê¸° ë°°ì¹˜ ---------- */
window.addEventListener('DOMContentLoaded', () => {
  layoutEdges();
  window.addEventListener('resize', layoutEdges);
  setTimeout(layoutEdges, 0);
});
updateDistanceTable();
</script>
</body>
</html>
