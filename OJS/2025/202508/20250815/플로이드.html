<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>í”Œë¡œì´ë“œâ€“ì›Œì…œ ì•Œê³ ë¦¬ì¦˜ ì‹œê°í™”</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh; color: #333;
    }
    .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
    .header { text-align: center; color: white; margin-bottom: 40px; }
    .header h1 { font-size: 3rem; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
    .header p { font-size: 1.2rem; opacity: 0.9; }

    .content-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 40px; }
    .card {
      background: white; border-radius: 15px; padding: 30px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2); transition: transform 0.3s ease;
    }
    .card:hover { transform: translateY(-5px); }
    .card h2 { color: #667eea; margin-bottom: 20px; font-size: 1.8rem; }

    .algorithm-steps { list-style: none; counter-reset: step-counter; }
    .algorithm-steps li {
      counter-increment: step-counter; margin-bottom: 15px; padding-left: 40px;
      position: relative; line-height: 1.6;
    }
    .algorithm-steps li::before {
      content: counter(step-counter); position: absolute; left: 0; top: 0;
      background: #667eea; color: white; width: 25px; height: 25px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9rem;
    }

    .visualization {
      grid-column: 1 / -1; background: white; border-radius: 15px; padding: 30px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }

    .controls { text-align: center; margin: 20px 0 10px; }
    .btn {
      background: #667eea; color: white; border: none; padding: 12px 24px; border-radius: 25px;
      font-size: 1rem; cursor: pointer; margin: 0 8px; transition: all 0.3s ease;
    }
    .btn:hover { background: #5a6fd8; transform: translateY(-2px); }
    .btn:disabled { background: #ccc; cursor: not-allowed; transform: none; }

    .status {
      display: grid; grid-template-columns: 1fr 2fr; gap: 10px; margin: 10px 0 10px;
    }
    .status .panel {
      background: #f8f9ff; border: 1px solid #e5e7ff; border-radius: 12px; padding: 16px;
    }
    .status .panel h3 { margin-bottom: 10px; color: #5a6fd8; }

    .formula { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    .table-wrap { overflow-x: auto; }
    table.matrix {
      width: 100%; border-collapse: collapse; margin-top: 10px;
    }
    .matrix th, .matrix td {
      border: 1px solid #ddd; padding: 10px; text-align: center; min-width: 60px;
    }
    .matrix th {
      background: #667eea; color: white; position: sticky; top: 0; z-index: 1;
    }
    .infinity { color: #999; }

    /* í•˜ì´ë¼ì´íŠ¸ */
    td.active { background: #fff3cd; font-weight: bold; }
    td.using  { background: #e7f1ff; }
    td.kline  { background: #f0e9ff; }
    td.updated { background: #c8e6c9; animation: pulse 0.5s ease; }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 rgba(76,175,80,0.6); }
      100% { box-shadow: 0 0 12px rgba(76,175,80,0.6) inset; }
    }

    /* ì‘ì€ ê·¸ë˜í”„ (ì˜µì…˜): í˜„ì¬ i-k, k-j ë…¸ë“œë§Œ í¬ì»¤ìŠ¤ìš© */
    .mini-graph {
      position: relative; height: 300px; margin-top: 10px;
      background: #fafafa; border: 1px dashed #e0e0e0; border-radius: 12px;
    }
    .node {
      width: 48px; height: 48px; border-radius: 50%;
      background: #f0f0f0; border: 3px solid #ddd;
      display: flex; align-items: center; justify-content: center;
      font-weight: bold; position: absolute; user-select: none;
      transition: transform .2s, box-shadow .2s;
    }
    .node.focus { transform: scale(1.1); box-shadow: 0 6px 18px rgba(0,0,0,0.15); border-color:#667eea; }
    svg { position:absolute; top:0; left:0; width:100%; height:100%; }
    line.hint { stroke:#bbb; stroke-width:3; }
    line.path { stroke:#ff9800; stroke-width:5; stroke-dasharray:6 6; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>í”Œë¡œì´ë“œâ€“ì›Œì…œ ì•Œê³ ë¦¬ì¦˜</h1>
      <p>ëª¨ë“  ì •ì ìŒ ìµœë‹¨ê±°ë¦¬(APS P)ë¥¼ ë™ì  ê³„íšë²•ìœ¼ë¡œ êµ¬í•˜ëŠ” ê³¼ì •ì„ ë‹¨ê³„ë³„ë¡œ ì‹œê°í™”í•©ë‹ˆë‹¤</p>
    </div>

    <div class="content-grid">
      <div class="card">
        <h2>ğŸ¯ ì•Œê³ ë¦¬ì¦˜ ê°œìš”</h2>
        <p><b>í”Œë¡œì´ë“œâ€“ì›Œì…œ</b>ì€ ì •ì  ìˆ˜ê°€ Vì¼ ë•Œ, ëª¨ë“  ìŒ (i, j)ì— ëŒ€í•´ ìµœë‹¨ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.</p>
        <br>
        <ul style="margin-left: 20px;">
          <li>ì…ë ¥ ê·¸ë˜í”„ì— <b>ìŒìˆ˜ ê°€ì¤‘ì¹˜</b>ëŠ” í—ˆìš©ë˜ì§€ë§Œ <b>ìŒìˆ˜ ì‚¬ì´í´</b>ì€ í—ˆìš©ë˜ì§€ ì•ŠìŒ</li>
          <li>ì‹œê°„ ë³µì¡ë„: <span class="mono">O(VÂ³)</span>, ê³µê°„ ë³µì¡ë„: <span class="mono">O(VÂ²)</span></li>
          <li>ì í™”ì‹: <span class="formula">dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])</span></li>
        </ul>
      </div>

      <div class="card">
        <h2>ğŸ“‹ ì•Œê³ ë¦¬ì¦˜ ë‹¨ê³„</h2>
        <ol class="algorithm-steps">
          <li>ì´ˆê¸°í™”: dist[i][i] = 0, ê°„ì„  (u, v, w)ëŠ” dist[u][v] = w (ë¬´ë°©í–¥ì´ë©´ ì–‘ìª½ ì„¤ì •)</li>
          <li>ì¤‘ê°„ ì •ì  kë¥¼ 0..V-1ë¡œ ì¦ê°€ì‹œí‚¤ë©°
            <ul style="margin-left: 16px; margin-top:6px;">
              <li>ëª¨ë“  (i, j)ì— ëŒ€í•´ <span class="formula">dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])</span> ì ìš©</li>
              <li>ë” ì§§ì•„ì§€ë©´ ê°±ì‹ </li>
            </ul>
          </li>
          <li>kê°€ ëë‚˜ë©´ ëª¨ë“  ìŒ ìµœë‹¨ê±°ë¦¬ ì™„ì„±</li>
        </ol>
      </div>
    </div>

    <div class="visualization">
      <h2 style="text-align:center; color:#667eea; margin-bottom: 8px;">ğŸ” ë‹¨ê³„ë³„ ì‹œê°í™”</h2>

      <div class="status">
        <div class="panel">
          <h3>í˜„ì¬ ìƒíƒœ</h3>
          <div id="stateText" class="mono">k = -, i = -, j = -</div>
          <div id="formulaText" class="formula" style="margin-top:8px;">
            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
          </div>
        </div>
        <div class="panel">
          <h3>ë¯¸ë‹ˆ ê·¸ë˜í”„ (iâ€“kâ€“j)</h3>
          <div class="mini-graph" id="miniGraph">
            <svg id="miniSvg"></svg>
            <div class="node" style="top: 30px; left: 40px;"  data-node="A">A</div>
            <div class="node" style="top: 30px; right: 40px;" data-node="C">C</div>
            <div class="node" style="bottom: 30px; left: 50%;" data-node="B" ></div>
            <div class="node" style="bottom: 30px; left: 50%; transform: translateX(-50%);" data-node="B">B</div>
            <!-- ì‹¤ì œ ë°°ì¹˜ëŠ” ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ë‹¤ì‹œ ì„¤ì • -->
          </div>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="startBtn">ì•Œê³ ë¦¬ì¦˜ ì‹œì‘</button>
        <button class="btn" id="nextBtn" disabled>ë‹¤ìŒ ë‹¨ê³„</button>
        <button class="btn" id="autoBtn" disabled>ìë™ ì¬ìƒ</button>
        <button class="btn" id="resetBtn">ì´ˆê¸°í™”</button>
      </div>

      <div class="card" style="margin-top:16px;">
        <h2 style="color:#667eea; margin-bottom:12px;">ê±°ë¦¬ í–‰ë ¬</h2>
        <div class="table-wrap">
          <table class="matrix" id="matrixTable"></table>
        </div>
      </div>
    </div>
  </div>
<script>
  /************** ë°ì´í„° (ë…¸ë“œ/ê·¸ë˜í”„) **************/
  const nodes = ['A','B','C','D','E']; // ì¸ë±ìŠ¤ 0..4
  const N = nodes.length;

  // ë¬´ë°©í–¥ ê·¸ë˜í”„
  const edges = [
    ['A','B',4], ['A','C',10], ['A','D',3],
    ['B','C',2], ['B','E',1],
    ['C','E',5],
    ['D','E',2]
  ];

  // dist, next í¬ì¸í„°(ê²½ë¡œë³µì›ìš©; ì—¬ê¸°ì„  í‘œì‹œë§Œ)
  let dist = Array.from({length:N}, _ => Array(N).fill(Infinity));
  let nextHop = Array.from({length:N}, _ => Array(N).fill(null));

  // ë°˜ë³µ ë³€ìˆ˜
  let k = 0, i = 0, j = 0;
  let running = false;
  let autoTimer = null;

  // ìµœê·¼ ë Œë” ìƒíƒœ(ë¦¬ì‚¬ì´ì¦ˆ ëŒ€ì‘ìš©)
  let lastRender = { i: null, k: null, j: null, hasIK: false, hasKJ: false };

  // DOM ì°¸ì¡°
  const startBtn = document.getElementById('startBtn');
  const nextBtn  = document.getElementById('nextBtn');
  const autoBtn  = document.getElementById('autoBtn');
  const resetBtn = document.getElementById('resetBtn');
  const matrixTable = document.getElementById('matrixTable');
  const stateText = document.getElementById('stateText');
  const formulaText = document.getElementById('formulaText');

  /************** ì´ˆê¸°í™” **************/
  function initMatrices() {
    for (let a=0; a<N; a++) {
      for (let b=0; b<N; b++) {
        dist[a][b] = (a===b) ? 0 : Infinity;
        nextHop[a][b] = (a===b) ? nodes[b] : null;
      }
    }
    // ë¬´ë°©í–¥ ê°„ì„  ë°˜ì˜
    edges.forEach(([uName,vName,w]) => {
      const u = nodes.indexOf(uName), v = nodes.indexOf(vName);
      dist[u][v] = Math.min(dist[u][v], w);
      dist[v][u] = Math.min(dist[v][u], w);
      nextHop[u][v] = vName;
      nextHop[v][u] = uName;
    });
  }

  function buildMatrixTable() {
    let html = '<thead><tr><th class="mono">i\\j</th>';
    for (let col=0; col<N; col++) html += `<th>${nodes[col]}</th>`;
    html += '</tr></thead><tbody>';

    for (let r=0; r<N; r++) {
      html += `<tr><th>${nodes[r]}</th>`;
      for (let c=0; c<N; c++) {
        const id = `cell-${r}-${c}`;
        const val = dist[r][c];
        html += `<td id="${id}">${formatVal(val)}</td>`;
      }
      html += '</tr>';
    }
    html += '</tbody>';
    matrixTable.innerHTML = html;
  }

  function formatVal(x) {
    return (x === Infinity) ? '<span class="infinity">âˆ</span>' : x;
  }

  function clearCellClasses() {
    matrixTable.querySelectorAll('td').forEach(td=>{
      td.classList.remove('active','using','kline','updated');
    });
  }

  function highlightStep(iIdx, kIdx, jIdx, didUpdate = false) {
  clearCellClasses();

  // kì˜ í–‰/ì—´ ì†Œí”„íŠ¸ ê°•ì¡°
  for (let c = 0; c < N; c++) document.getElementById(`cell-${kIdx}-${c}`).classList.add('kline');
  for (let r = 0; r < N; r++) document.getElementById(`cell-${r}-${kIdx}`).classList.add('kline');

  // ì‚¬ìš©ë˜ëŠ” í•­: (i,k), (k,j)
  document.getElementById(`cell-${iIdx}-${kIdx}`).classList.add('using');
  document.getElementById(`cell-${kIdx}-${jIdx}`).classList.add('using');

  // ëŒ€ìƒ ì…€: (i,j)
  const tgt = document.getElementById(`cell-${iIdx}-${jIdx}`);
  tgt.classList.add('active');
  if (didUpdate) tgt.classList.add('updated');

  // ìƒíƒœ í…ìŠ¤íŠ¸
  const iN = nodes[iIdx], jN = nodes[jIdx], kN = nodes[kIdx];
  stateText.textContent = `k = ${kN}, i = ${iN}, j = ${jN}`;

  // ê°’ ì¤€ë¹„
  const dijVal = dist[iIdx][jIdx];
  const dikVal = dist[iIdx][kIdx];
  const dkjVal = dist[kIdx][jIdx];
  const dij = displayVal(dijVal);
  const dik = displayVal(dikVal);
  const dkj = displayVal(dkjVal);
  const sum = (dikVal === Infinity || dkjVal === Infinity) ? 'âˆ' : (dikVal + dkjVal);
  const best = (typeof sum === 'number') ? Math.min(dijVal, sum) : (dijVal === Infinity ? 'âˆ' : dijVal);

  // ìˆ˜ì‹(ê¸°í˜¸í˜• + ìˆ«ìí˜• + ê²°ê³¼)
  const leftSym = `dist[${iN}][${jN}]`;
  const rightSym = `min( ${leftSym}, dist[${iN}][${kN}] + dist[${kN}][${jN}] )`;
  const rightNum = `min( ${dij}, ${dik} + ${dkj} )`;
  const bestStr = (best === Infinity) ? 'âˆ' : String(best);

  formulaText.innerHTML = `
    ${leftSym} = ${rightSym}<br/>
    = ${rightNum}<br/>
    = <b>${bestStr}</b>
  `;

  // ì „ì²´ ê·¸ë˜í”„(5ë…¸ë“œ) í¬ì»¤ìŠ¤/ê²½ë¡œ í‘œì‹œ
  renderFullGraph(iIdx, kIdx, jIdx, (dikVal !== Infinity), (dkjVal !== Infinity));
}
  function minDisplay(a, b) {
    if (a === 'âˆ' && b === 'âˆ') return 'âˆ';
    if (a === 'âˆ') return b;
    if (b === 'âˆ') return a;
    return Math.min(Number(a), Number(b));
  }

  function displayVal(v) { return (v===Infinity) ? 'âˆ' : String(v); }

  /************** í•œ ìŠ¤í… ì§„í–‰ (i,j í•œ ì¹¸) **************/
  function step() {
    if (!running) return;

    const iIdx = i, jIdx = j, kIdx = k;
    const alt = (dist[iIdx][kIdx] === Infinity || dist[kIdx][jIdx] === Infinity)
      ? Infinity
      : dist[iIdx][kIdx] + dist[kIdx][jIdx];

    let updated = false;
    if (alt < dist[iIdx][jIdx]) {
      dist[iIdx][jIdx] = alt;
      nextHop[iIdx][jIdx] = nextHop[iIdx][kIdx];
      const cell = document.getElementById(`cell-${iIdx}-${jIdx}`);
      if (cell) cell.innerHTML = formatVal(alt);
      updated = true;
    }

    highlightStep(iIdx, kIdx, jIdx, updated);

    // ì¸ë±ìŠ¤ ì§„í–‰: j -> i -> k
    j++;
    if (j >= N) { j = 0; i++; }
    if (i >= N) { i = 0; k++; }

    // ì¢…ë£Œ ì¡°ê±´
    if (k >= N) {
      running = false;
      nextBtn.disabled = true;
      autoBtn.textContent = 'ìë™ ì¬ìƒ';
      autoBtn.disabled = true;
      startBtn.disabled = false;
      clearInterval(autoTimer);
    }
  }

  /************** ì»¨íŠ¸ë¡¤ **************/
  function start() {
    reset(false);
    running = true;
    startBtn.disabled = true;
    nextBtn.disabled = false;
    autoBtn.disabled = false;
    // ì²« ì…€ í•˜ì´ë¼ì´íŠ¸ë§Œ ë³´ì—¬ì£¼ê¸°
    highlightStep(0,0,0,false);
  }

  function toggleAuto() {
    if (!running) return;
    if (autoTimer) {
      clearInterval(autoTimer);
      autoTimer = null;
      autoBtn.textContent = 'ìë™ ì¬ìƒ';
    } else {
      autoBtn.textContent = 'ì¼ì‹œì •ì§€';
      autoTimer = setInterval(()=>{
        step();
        if (!running) { clearInterval(autoTimer); autoTimer=null; }
      }, 600);
    }
  }

  function reset(enableButtons = true) {
    // ìƒíƒœ ë¦¬ì…‹
    k = 0; i = 0; j = 0;
    running = false;
    clearInterval(autoTimer); autoTimer = null;

    // í–‰ë ¬ ë¦¬ì…‹
    initMatrices();
    buildMatrixTable();
    clearCellClasses();

    // í…ìŠ¤íŠ¸ ë¦¬ì…‹
    stateText.textContent = 'k = -, i = -, j = -';
    formulaText.innerHTML = 'dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])';

    // ì „ì²´ ê·¸ë˜í”„ ë¦¬ì…‹
    renderFullGraph(null,null,null,false,false);

    if (enableButtons) {
      startBtn.disabled = false;
      nextBtn.disabled  = true;
      autoBtn.disabled  = true;
      autoBtn.textContent = 'ìë™ ì¬ìƒ';
    }
  }

  /************** ì „ì²´ ê·¸ë˜í”„(5ë…¸ë“œ) ì‹œê°í™” **************/
  const NODE_SIZE = 48; // CSSì™€ ì¼ì¹˜
  function setupFullGraph() {
    const miniGraph = document.getElementById('miniGraph');
    miniGraph.innerHTML = `<svg id="miniSvg"></svg>`;
    // 5ê°œ ë…¸ë“œ ìƒì„±
    nodes.forEach(name => {
      const d = document.createElement('div');
      d.className = 'node';
      d.dataset.node = name;
      d.textContent = name;
      miniGraph.appendChild(d);
    });
  }

  // ì „ì²´ ê·¸ë˜í”„(5ë…¸ë“œ) ì‹œê°í™” â€” ê°€ì¤‘ì¹˜ ë¼ë²¨ ì¶”ê°€ ë²„ì „
function renderFullGraph(iIdx, kIdx, jIdx, hasIK, hasKJ) {
  const ctn = document.getElementById('miniGraph');
  if (!ctn) return;

  // ì²˜ìŒì—ë§Œ êµ¬ì„±
  if (!ctn.querySelector('#miniSvg') || ctn.querySelectorAll('.node').length !== N) {
    setupFullGraph();
  }

  const svg = ctn.querySelector('#miniSvg');

  // ì›í˜• ë°°ì¹˜ ì¢Œí‘œ ê³„ì‚°
  const w = ctn.clientWidth, h = ctn.clientHeight;
  const cx = w/2, cy = h/2;
  const R = Math.min(w, h) * 0.38;

  const pos = {}; // name -> {x,y}
  nodes.forEach((name, idx) => {
    const ang = -Math.PI/2 + 2*Math.PI*idx/N;
    pos[name] = { x: cx + R*Math.cos(ang), y: cy + R*Math.sin(ang) };
  });

  // ë…¸ë“œ ë°°ì¹˜ + ê¸°ë³¸ ìŠ¤íƒ€ì¼ ì´ˆê¸°í™”
  nodes.forEach(name => {
    const el = ctn.querySelector(`.node[data-node="${name}"]`);
    if (!el) return;
    el.style.left = (pos[name].x - NODE_SIZE/2) + 'px';
    el.style.top  = (pos[name].y - NODE_SIZE/2) + 'px';
    el.classList.remove('focus');
    el.style.borderColor = '#ddd';
    el.style.boxShadow = 'none';
  });

  // SVG ë ˆì´ì–´ êµ¬ì„±: ê¸°ë³¸ ê°„ì„ , ê°•ì¡° ê°„ì„ , ë¼ë²¨ ìˆœì„œë¡œ ê·¸ë ¤ ê°€ë…ì„± ìœ ì§€
  let baseLines = '';
  let highlightLines = '';
  let labels = '';

  // ê¸°ë³¸ ê°„ì„  + ë¼ë²¨
  edges.forEach(([u, v, wgt]) => {
    const p1 = pos[u], p2 = pos[v];
    baseLines += `<line class="hint" x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" />`;

    // ë¼ë²¨ ìœ„ì¹˜: ì¤‘ì ì—ì„œ ë²•ì„  ë°©í–¥ìœ¼ë¡œ ì‚´ì§(14px) ë°€ê¸°
    const mx = (p1.x + p2.x) / 2, my = (p1.y + p2.y) / 2;
    const dx = p2.x - p1.x, dy = p2.y - p1.y;
    const len = Math.hypot(dx, dy) || 1;
    let nx = -dy / len, ny = dx / len; // ë²•ì„ 

    // ë¼ë²¨ì´ ê·¸ë˜í”„ ë°”ê¹¥ìª½ìœ¼ë¡œ ê°€ë„ë¡ ë²•ì„  ë°©í–¥ ì„ íƒ
    const vx = mx - cx, vy = my - cy;
    if (nx*vx + ny*vy < 0) { nx = -nx; ny = -ny; }

    const offset = 14;
    const lx = mx + nx * offset;
    const ly = my + ny * offset;

    // í…ìŠ¤íŠ¸ í…Œë‘ë¦¬(stroke)ë¡œ ê°€ë…ì„± í™•ë³´ (ë°°ê²½ ë°•ìŠ¤ ì—†ì´)
    labels += `
      <text x="${lx.toFixed(1)}" y="${ly.toFixed(1)}"
            font-size="12" text-anchor="middle" dominant-baseline="middle"
            fill="#111" stroke="#fff" stroke-width="3" paint-order="stroke"
            style="pointer-events:none;">
        ${wgt}
      </text>`;
  });

  // i, k, j í¬ì»¤ìŠ¤ & ê°œë… ê²½ë¡œ(ì ì„  ì£¼í™©)
  if (iIdx !== null && kIdx !== null && jIdx !== null) {
    const iN = nodes[iIdx], kN = nodes[kIdx], jN = nodes[jIdx];

    // í¬ì»¤ìŠ¤ íš¨ê³¼
    [iN,kN,jN].forEach(name => {
      const el = ctn.querySelector(`.node[data-node="${name}"]`);
      if (el) { el.classList.add('focus'); el.style.boxShadow = '0 6px 18px rgba(0,0,0,0.15)'; }
    });
    // ì—­í• ë³„ í…Œë‘ë¦¬ ìƒ‰
    const iEl = ctn.querySelector(`.node[data-node="${iN}"]`);
    const kEl = ctn.querySelector(`.node[data-node="${kN}"]`);
    const jEl = ctn.querySelector(`.node[data-node="${jN}"]`);
    if (iEl) iEl.style.borderColor = '#ff9800';
    if (kEl) kEl.style.borderColor = '#667eea';
    if (jEl) jEl.style.borderColor = '#ff9800';

    if (hasIK) {
      highlightLines += `<line class="path" x1="${pos[iN].x}" y1="${pos[iN].y}" x2="${pos[kN].x}" y2="${pos[kN].y}" />`;
    }
    if (hasKJ) {
      highlightLines += `<line class="path" x1="${pos[kN].x}" y1="${pos[kN].y}" x2="${pos[jN].x}" y2="${pos[jN].y}" />`;
    }
  }

  // ê·¸ë¦¬ê¸°: ê¸°ë³¸ì„  â†’ ê°•ì¡°ì„  â†’ ë¼ë²¨(ë§¨ ìœ„)
  svg.innerHTML = baseLines + highlightLines + labels;

  // ë§ˆì§€ë§‰ ë Œë” ìƒíƒœ ì €ì¥(ë¦¬ì‚¬ì´ì¦ˆ ëŒ€ì‘)
  lastRender = { i: iIdx, k: kIdx, j: jIdx, hasIK, hasKJ };
}

  // ë¦¬ì‚¬ì´ì¦ˆ ì‹œ ì¬ë Œë”
  window.addEventListener('resize', () => {
    renderFullGraph(lastRender.i, lastRender.k, lastRender.j, lastRender.hasIK, lastRender.hasKJ);
  });

  /************** ì´ë²¤íŠ¸ **************/
  startBtn.addEventListener('click', start);
  nextBtn.addEventListener('click', step);
  autoBtn.addEventListener('click', toggleAuto);
  resetBtn.addEventListener('click', ()=>reset(true));

  // ì²˜ìŒ ë Œë”
  initMatrices();
  buildMatrixTable();
  renderFullGraph(null,null,null,false,false);
</script>

</body>
</html>
